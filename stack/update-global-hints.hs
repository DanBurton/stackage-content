#!/usr/bin/env stack
-- stack --resolver lts-12.0 script
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
import Data.Yaml
import RIO
import qualified RIO.Map as Map
import qualified RIO.Text as T
import System.Environment (getArgs)
import RIO.Process
import Distribution.Types.PackageId
import qualified RIO.ByteString.Lazy as BL
import qualified Distribution.Text as DT (simpleParse, display)

comment :: ByteString
comment =
  "# Packages found in the global package database for each GHC version.\n\
  \# Used by post-pantry Stack (merged to master August 2018).\n\
  \# This file auto-generated by update-global-hints.hs.\n\
  \# Please ensure this is updated when a new version of GHC is released.\n\n"

main :: IO ()
main = runSimpleApp $ do
  args <- liftIO getArgs
  when (null args) $ error $ "Please provide a list of GHC versions, e.g. ./update-global-hints.hs ghc-8.4.3 ghc-8.4.2"

  let fp = "global-hints.yaml"
  -- liftIO $ decodeFileThrow fp >>= \v -> error (show (v :: Value))
  eoldMap <- liftIO $ decodeFileEither fp
  oldMap <-
    case eoldMap of
      Left e -> do
        logError "Could not open existing global-hints.yaml"
        logError $ displayShow e
        pure mempty
      Right x -> pure (x :: Map Text (Map Text Text))

  pairs <- for args $ \ghcVer -> do
    let args' =
          [ "--resolver"
          , ghcVer
          , "exec"
          , "--no-ghc-package-path"
          , "--"
          , "ghc-pkg"
          , "list"
          , "--global"
          , "--no-user-package-db"
          , "--simple-output"
          ]
    outLBS <- proc "stack" args' readProcessStdout_
    outText <-
      case decodeUtf8' $ BL.toStrict outLBS of
        Left e -> throwIO e
        Right x -> pure x
    pairs <- for (T.words outText) $ \pkgver ->
      case DT.simpleParse $ T.unpack pkgver of
        Nothing -> error $ "Invalid package id: " ++ show pkgver
        Just (PackageIdentifier name ver) ->
          pure (T.pack $ DT.display name, T.pack $ DT.display ver)
    pure (T.pack ghcVer, Map.fromList pairs)

  let bs = encode $ Map.fromList pairs <> oldMap
  writeFileBinary fp $ comment <> bs
